\documentclass[a4paper,12pt]{article} 
\usepackage[utf8]{inputenc} % Acentos válidos sin problemas
\usepackage[spanish]{babel} % Idioma
\input{packet}


\begin{document}%----------------------INICIO DOCUMENTO------------|
%------------------------------------------------------------------|

\newpage

\input{portada}

\newpage

\begin{center}
    {\Large Algoritmo Dijkstra Distribuido}
\end{center}

\section*{Forma de compilar}
\subsubsection*{Se añade en el readme.txt}

El comando para compilar es:
\begin{center}
    $\$$ gcc -o .$\backslash$Practica01EdgarLedesma$\_$CarlosCortes$\_$MarcoSilva .$\backslash$Practica01$\_$EdgarLedesma$\_$CarlosCortes$\_$MarcoSilva.c -pthread
\end{center}

El comando para ejecutar es:

\begin{center}
    $\$$ .$\backslash$Practica01$\_$EdgarLedesma$\_$CarlosCortes$\_$MarcoSilva
\end{center}

\section*{Pseudocódigo del Algoritmo}
\begin{verbatim}
    1. Inicializar todas las distancias en D con un valor infinito relativo, 
       ya que son desconocidas al principio, exceptuando la de a, 
       qué se debe colocar en 0, pues la distancia de a a si mismo sería 0. 
       C es copia de V        
    
    2. Para todo vértice i en C se establece [PI]= a.        
    
    3. Se obtiene el vértice s en C tal que no existe otro vértice w en C 
       tal que (D[w] < D[s]). 
       Para esto se envía un mensaje al nodo correspondiente y se regresa
       un mensaje de respuesta en donde se toma el tiempo y se le asigna a 
       su distancia correspondiente. De manera concurrente el nodo destino 
       realiza el mismo procedimiento para calcular su distancia a sus nodos
       vecinos que no han sido visitados.
    
        // En lugar de buscar el vértice con la distancia más corta 
        // iterativamente, ahora se utiliza una heap para mantener una lista 
        // de vértices no visitados, ordenada por la distancia más corta. Así 
        // encontrar el vértice n la distancia más corta en tiempo logarítmico.    
    
    4. Se elimina de C el vértice s. El vértice u se elimina del conjunto C.
    
    5. Para cada arista e en E de longitud l, 
       que une el vértice s con algún otro vértice t en C,
       Para cada arista que sale del vértice u, se verifica si la distancia 
       a través del vértice u es menor que la distancia actual del vértice t.
    
        - Si l + D[s] < D[t], entonces:
         // Si la distancia a través del vértice u es menor que la distancia 
         // actual del vértice t, entonces se actualiza la distancia del vértice t.
        - Se establece D[t] :=  l + D[s].
         // La distancia del vértice t se establece en la suma de la distancia 
         // del vértice u y el peso de la arista.
        - Se establece P[t] := s.
        // El predecesor del vértice t se establece en el vértice u.
    
    6. Se regresa al paso 4.
        // El algoritmo regresa al paso 4 y repite el proceso hasta que todos
        // los vértices hayan sido visitados.    
\end{verbatim}
    

\section*{Desarrollo}

Un algoritmo distribuido es un algoritmo que se ejecuta en múltiples procesos que se comunican entre sí a través de una red. El algoritmo de Dijkstra es un algoritmo de búsqueda de caminos más cortos. En la implementación distribuida del algoritmo de Dijkstra, cada vértice de la gráfica se ejecuta en un proceso separado. Los procesos se comunican entre sí para intercambiar información sobre las distancias entre los vértices. El código de la implementación distribuida del algoritmo de Dijkstra se divide en las siguientes partes:

\begin{itemize}
    \item Inicialización: En esta parte, se inicializa el grafo y se establece el nodo de origen.
    \item Ejecución del algoritmo: En esta parte, se ejecuta el algoritmo de Dijkstra de forma iterativa. En cada iteración, se encuentra el vértice con la distancia más corta que aún no se ha visitado. Luego, se actualizan las distancias de los vértices vecinos del vértice seleccionado.
    \item Impresión de los resultados: En esta parte, se imprimen las distancias y las rutas más cortas.
\end{itemize}

\textbf{Dificultades en la simulación:} La mayor dificultad en la simulación de que el código fuera distribuido fue la implementación de la comunicación entre los procesos. Para resolver este problema, se utilizó la biblioteca de hilos de C$++$.

\textbf{Uso de hilos:} Se utilizó la biblioteca de hilos de C$++$ para implementar la comunicación entre los procesos. Cada vértice se ejecuta en un hilo separado. Los hilos se comunican entre sí a través de variables compartidas.

\textbf{Razones para el uso de hilos:} Se utilizó hilos para implementar la comunicación entre los procesos porque es una forma eficiente de realizar comunicaciones entre procesos en un sistema operativo multiproceso.


\section*{Funcionamiento}

\begin{itemize}
    \item \texttt{inicio$\_$grafica(struct grafica* g, int nvertices)}:
    
    Este método se encarga de inicializar el grafo con retrasos aleatorios. Recibe un puntero a una estructura \texttt{grafica} y el número de vértices \texttt{nvertices} como argumentos. Primero, asigna el número de vértices al grafo. Luego, inicializa cada vértice con valores predeterminados y genera aristas con pesos aleatorios entre 1 y 1000 que conectan los vértices.

    \item \texttt{encontrar$\_$minimo(int distancias[], bool conjunto$\_$cerrado[], int nvertices)}: 
    
    Esta función encuentra el vértice con la distancia mínima en el conjunto de vértices no visitados. Recibe un arreglo de distancias, un arreglo booleano que indica si un vértice está en el conjunto cerrado y el número de vértices como argumentos. Devuelve el índice del vértice con la distancia mínima.

    \item \texttt{imprimir$\_$ruta(int predecesores[], int nodo)}:
    
    Este método imprime la ruta desde el origen hasta un vértice dado. Recibe un arreglo de predecesores y el nodo de destino como argumentos. Utiliza la recursión para imprimir la ruta en el formato nodo1 $\rightarrow$ nodo2 $\rightarrow$ ... $\rightarrow$ nodoN.

    \item \texttt{imprimir$\_$arbol$\_$generador(int predecesores[], int nvertices)}: 
    
    Este método imprime el árbol generador mínimo del grafo. Recibe un arreglo de predecesores y el número de vértices como argumentos. Muestra las aristas del árbol generador, indicando las conexiones entre los vértices.

    \item \texttt{dijkstra$\_$distribuido(struct grafica* g, int origen)}: 
    
    Este es el método principal que implementa el algoritmo de Dijkstra distribuido. Recibe un puntero a una estructura \texttt{grafica} y el nodo de origen como argumentos. Calcula las rutas más cortas desde el nodo de origen hacia todos los demás nodos en el grafo. Utiliza el arreglo de distancias, el conjunto cerrado y los predecesores para realizar los cálculos. Al final, imprime las distancias y las rutas más cortas, así como el árbol generador mínimo del grafo.

    \item \texttt{main()}: 
    
    La función principal del programa. En esta función se crea una estructura \texttt{grafica}, se establece el número de vértices y el nodo de origen. Luego, se llama a \texttt{dijkstra$\_$distribuido} para encontrar las rutas más cortas y mostrar los resultados.
\end{itemize}







\end{document}%---------------------- FIN DOCUMENTO---------------|
%-----------------------------------------------------------------|